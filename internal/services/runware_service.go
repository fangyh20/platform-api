package services

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/google/uuid"
)

type RunwareService struct {
	APIKey string
}

type runwareRequest struct {
	TaskType       string `json:"taskType"`
	TaskUUID       string `json:"taskUUID"`
	PositivePrompt string `json:"positivePrompt"`
	Model          string `json:"model"`
	NumberResults  int    `json:"numberResults"`
	Height         int    `json:"height"`
	Width          int    `json:"width"`
	OutputFormat   string `json:"outputFormat"`
}

type runwareResponse struct {
	Data []struct {
		ImageURL string `json:"imageURL"`
	} `json:"data"`
}

func NewRunwareService(apiKey string) *RunwareService {
	return &RunwareService{
		APIKey: apiKey,
	}
}

// GenerateLogo generates an app logo using Runware AI
func (s *RunwareService) GenerateLogo(appName, category, colorScheme string) (string, error) {
	// Create prompt for logo generation
	prompt := fmt.Sprintf(`Modern, minimalist app icon logo for "%s".
Style: Flat design, clean geometric shapes, %s color palette.
Category: %s.
Professional, simple, no text in the icon.
Square format, centered design.
Suitable for app icon and branding.`, appName, colorScheme, category)

	reqBody := runwareRequest{
		TaskType:       "imageInference",
		TaskUUID:       uuid.New().String(),
		PositivePrompt: prompt,
		Model:          "runware:100@1", // Fast model
		NumberResults:  1,
		Height:         512,
		Width:          512,
		OutputFormat:   "PNG",
	}

	// Runware API expects an array of requests
	jsonData, err := json.Marshal([]runwareRequest{reqBody})
	if err != nil {
		return "", fmt.Errorf("failed to marshal request: %w", err)
	}

	// Call Runware API
	req, err := http.NewRequest("POST", "https://api.runware.ai/v1", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", s.APIKey))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 60 * time.Second} // Logo generation can take time
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to call Runware API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("Runware API error (status %d): %s", resp.StatusCode, string(body))
	}

	// Parse response
	var runwareResp runwareResponse
	if err := json.NewDecoder(resp.Body).Decode(&runwareResp); err != nil {
		return "", fmt.Errorf("failed to decode Runware response: %w", err)
	}

	if len(runwareResp.Data) == 0 {
		return "", fmt.Errorf("no image generated by Runware")
	}

	return runwareResp.Data[0].ImageURL, nil
}

// DownloadImage downloads the image from URL
func (s *RunwareService) DownloadImage(imageURL string) ([]byte, error) {
	resp, err := http.Get(imageURL)
	if err != nil {
		return nil, fmt.Errorf("failed to download image: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download image (status %d)", resp.StatusCode)
	}

	return io.ReadAll(resp.Body)
}
